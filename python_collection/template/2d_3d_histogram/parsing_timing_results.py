import matplotlib.colors as colors
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import os
import itertools
import sys
from math import *
import operator
import pylab
import os
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import sys
import matplotlib.pyplot as plt
from list_all_files_in_a_folder import *
import numpy
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import cm
plt.ioff()
import gen_color_spec 


def sourceFileParse(sourceFileName, clk_period):
    
    number_of_paths = 0 
    data = {}
    # if not(os.path.isfile(sourceFileName)):
        # print "the source file doesn't exist"
        # exit();
    adjust = False 
    try:
        f = open(sourceFileName)
    except IOError:
        handleIOError(sourceFileName, "csource file")
        exit()
    else:
        with f:
            for line in f:
                word_list =   line.strip().replace(',', ' ').replace('/','').replace(';', ' ').split(' ') #find the lines with key word and write it to another file   
                if word_list[0] == "Startpoint:":
                    input_pin = word_list[1]
                    input_pin_number = (word_list[1]).replace('[',',').replace(']',',').split(',')[1]
                if word_list[0] == "Endpoint:":
                    output_pin = word_list[1] 
                    output_pin_number = (word_list[1]).replace('[',',').replace(']',',').split(',')[1]
                if (word_list[0] == "data") and (word_list[1] == "required") and word_list[2] == "time":
                    offset = clk_period - float(word_list[-1])
#                    if (float(word_list[-1]) in [1.46, 1.47]):
#                        adjust = True 
                if word_list[0] == "slack":
                    #print output_pin_number, input_pin_number,  word_list[-1]
                    number_of_paths +=1 
                    if  (int(input_pin_number), int(output_pin_number)) in data:
                        data[(int(input_pin_number),
                            int(output_pin_number))].append(float(word_list[-1])
                                    + offset)
                    else:
                        
                        data[(int(input_pin_number), int(output_pin_number))] = [(float(word_list[-1])) + offset] 
    #print data
    print "number_of_paths:" + str(number_of_paths)
    return data


def main():
    
    os.system("rm *.png")
    #--- parameters to set
    clk_period = .7 #clk period that we ran the DC with
    num_of_bins = 10  #number of bins for the histogram
    lower_bound = 28 #lower bound for the output bit you want to make histogram for
    upper_bound = 32 #upper bound for the output bit you want to make histogram for
    histogram_type = "2d"   #2d
                            #3d histogram will be generated regardless
    output_bit_to_make_histogram_for = 31  #only for 2d histogram
   
    
    print "clk_period:" +str(clk_period)
    print "number_of_bins for histogram:" +str(num_of_bins)
    #--- parse the results and collect slacks   
    data = sourceFileParse("int_add_acc_ff_0_timing1.rpt", clk_period)


    #sorting for printing purposes
    my_list = data.keys()
    my_list.sort(key=lambda x: x[0])
    my_list.sort(key=lambda x: x[1])
    for key in my_list:
        print str("pin_tuple:")+str(key) + " ---- slack_values" + str(data[key])


    #--- preparing to draw a histogram
    output_slack_dic = {}
    for i in range(0, 32):
        output_slack_dic[i] = []

    for key in data.keys():
        output_slack_dic[key[1]].append(data[key]) 

    #flattening
    for key in output_slack_dic.keys():
        output_slack_dic[key] = list(itertools.chain.from_iterable(output_slack_dic[key]))

    
    #--- draw a 2d histogram
    if (histogram_type == "2d"): 
        plt.hist(output_slack_dic[output_bit_to_make_histogram_for], 30,
                range=[0, clk_period])
        print output_slack_dic[output_bit_to_make_histogram_for]
        plt.title("slack Histogram for " + str(output_bit_to_make_histogram_for) + "thbit")
        plt.xlabel("Value")
        plt.ylabel("Frequency")
        pylab.savefig(str(output_bit_to_make_histogram_for) +"th_bit_slack_histogram.png") #saving the figure generated by generateGraph
        #plt.show()
    
    #--- draw a 3d histogram
    fig = plt.figure()
    ax1 = fig.add_subplot(111, projection='3d')
    x = [] #list of output bits (stamped to the number of slack value)
    y = [] #list of slack value
    for key in output_slack_dic.keys():
        x += len(output_slack_dic[key])*[key]
        y += output_slack_dic[key]
    xedges = []
    for i in range(0,33):
        xedges.append(i)
    yedges = [] 
    for el in range(num_of_bins):
        yedges.append((el+1)*float(clk_period)/float(num_of_bins))
    H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
    
    new_yedges = []
    for i in range(0, len(xedges[:-1])):
        for el in yedges[:-1]:
            new_yedges.append(float(el))

    new_xedges = []
    for j in range (0, len(xedges[:-1])):
        for i in range(0, len(yedges[:-1])):
            new_xedges.append(j)

    dx = np.ones(len(new_xedges))
    dy = np.ones(len(new_xedges))*.1

    colors = gen_color_spec.gen_color(33, 'prism')
    for x in range(lower_bound, upper_bound):
        ax1.bar3d([x]*len(yedges[:-1]), yedges[:-1], np.zeros(len(yedges[:-1])), dx,
                dy,H[x], alpha =.5, color=colors[x])
    
    
        print "x and y for hisogram:"
        print "y:" + str(np.array(yedges))
        print "x " + str(xedges)
        print  "histogram:"
        print H
    
        """ 
        H_list = (H.tolist())
        H_list_flattened = list(itertools.chain.from_iterable(H_list))
        dz = H_list_flattened
        zpos =[0]*len(H_list_flattened)
        ax1.bar3d(new_xedges, new_yedges, zpos, dx, dy, dz, alpha =.1, color='#00ceaa')
        """ 
        pylab.savefig("3d_slack_histogram.png") #saving the figure generated by generateGraph


main()
